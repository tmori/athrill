
		TOPPERS/ATK2-SC1-MC
		ターゲット依存部 ポーティングガイド

このドキュメントは，TOPPERS/ATK2-SC1-MCを，未サポートのターゲットシス
テムにポーティングするために必要となるターゲット依存部の実装方法を説明
するものである．

----------------------------------------------------------------------
TOPPERS ATK2
    Toyohashi Open Platform for Embedded Real-Time Systems
    Automotive Kernel Version 2

Copyright (C) 2011-2017 by Center for Embedded Computing Systems
            Graduate School of Information Science, Nagoya Univ., JAPAN
Copyright (C) 2011-2017 by FUJI SOFT INCORPORATED, JAPAN
Copyright (C) 2011-2013 by Spansion LLC, USA
Copyright (C) 2011-2017 by NEC Communication Systems, Ltd., JAPAN
Copyright (C) 2011-2016 by Panasonic Advanced Technology Development Co., Ltd., JAPAN
Copyright (C) 2011-2014 by Renesas Electronics Corporation, JAPAN
Copyright (C) 2011-2016 by Sunny Giken Inc., JAPAN
Copyright (C) 2011-2017 by TOSHIBA CORPORATION, JAPAN
Copyright (C) 2011-2017 by Witz Corporation
Copyright (C) 2014-2016 by AISIN COMCRUISE Co., Ltd., JAPAN
Copyright (C) 2014-2016 by eSOL Co.,Ltd., JAPAN
Copyright (C) 2014-2017 by SCSK Corporation, JAPAN
Copyright (C) 2015-2017 by SUZUKI MOTOR CORPORATION

上記著作権者は，以下の (1)〜(3)の条件を満たす場合に限り，本ドキュメ
ント（本ドキュメントを改変したものを含む．以下同じ）を使用・複製・改
変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
(1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
    および下記の無保証規定が，そのままの形でドキュメント中に含まれて
    いること．
(2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
    を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
    ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
    りではない．
(3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
    からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
    本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
    く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

本ドキュメントは，AUTOSAR（AUTomotive Open System ARchitecture）仕様
に基づいている．上記の許諾は，AUTOSARの知的財産権を許諾するものではな
い．AUTOSARは，AUTOSAR仕様に基づいたソフトウェアを商用目的で利用する
者に対して，AUTOSARパートナーになることを求めている．

本ドキュメントは，無保証で提供されているものである．上記著作権者およ
びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
により直接的または間接的に生じたいかなる損害に関しても，その責任を負
わない．

$Id: porting.txt 2401 2017-03-14 09:09:24Z witz-itoyo $
----------------------------------------------------------------------

○目次

◎０．前提
	◎0.1 本マニュアルの位置づけ
	◎0.2 動作アーキテクチャ
１．共通事項
	1.1 ターゲット依存部の構成
	1.2 多重インクルードの防止
	1.3 アセンブリ言語とのヘッダファイルの共用 
	1.4 インクルード記述の方法
	1.5 クリティカルセクションの出入処理の実現に関する制約
	1.6 名前の衝突の防止
２．システム構築環境のターゲット依存部
	2.1 ターゲット略称とターゲット依存部のディレクトリ
	2.2 Makefileのターゲット依存部
	2.3 開発環境名とコマンド名の設定
	2.4 コンパイルオプションとオブジェクトファイルの設定
	2.5 オフセットファイルの生成方法
		2.5.1 ジェネレータを用いる方法
	2.6 リンク方法の設定
	2.7 依存関係の定義
	2.8 その他の設定
３．AUTOSAR共通定義のターゲット依存部
	3.1 整数型の最大値・最小値・ビット数
	3.2 整数型
	3.3 論理型，論理型の値
	3.4 その他の型
	3.5 コンパイラの拡張機能のためのマクロ定義
	3.6 標準的な定義の上書き
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	○4.1 全割込み禁止状態の管理
	4.2 プロセッサのエンディアン
	4.3 I/O空間アクセス関数
	◎4.4 スピンロック機能
	◎4.5 コアIDの取得
５．カーネルAPIのターゲット依存部
	5.1 メモリ領域確保のための型定義
	5.2 メモリ領域確保のためのマクロ
	○5.3 オブジェクト型の上書き
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
		6.1.1 カーネル実装のターゲット依存部の構成要素
		6.1.2 ターゲット依存部の関数の命名規則
	6.2 トレースログ機能への対応
	6.3 システム状態の管理
		6.3.1 全割込み禁止状態の管理
		6.3.2 コンテキストの管理
		6.3.3 OS割込み禁止状態の管理
	6.4 割込みに関連するシステム状態の管理
		6.4.1 割込み優先度マスクの管理
		6.4.2 割込みハンドラの先頭処理と末尾処理
	6.5 タスクディスパッチャ
		6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック
		○6.5.2 ディスパッチャ本体
		○6.5.3 タスクコンテキストからのディスパッチ
		○6.5.4 ディスパッチャの動作開始
		6.5.5 現在のコンテキストを捨ててディスパッチ
		6.5.6 タスクの起動処理
	○6.6 割込みハンドラ
		○6.6.1 割込みハンドラの出入口処理
		6.6.2 割込み要求ラインの属性の設定
		6.6.3 割込み管理機能の初期化処理の変更
		6.6.4 デフォルトのC2ISR
		6.6.5 カーネル管理外の割込み
		6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更
		◎6.6.7 割込み番号のマルチコア拡張
	6.7 スタックモニタリング
	6.8 CPU例外ハンドラ
	6.9 エラーフック，シャットダウンフック呼び出し
	○6.10 カーネルの起動・終了とスタック領域など
	6.11 カーネル内部のチューニング
		6.11.1 ビットマップサーチ
	6.12 カーネル実装に関するその他の定義
		6.12.1 エラーチェック方法の指定
		6.12.2 非タスクコンテキスト用のスタック領域
		6.12.3 空ラベルの定義
		6.12.4 各スタックのデフォルト値
		6.12.5 スタックマジックナンバー領域操作マクロの定義
	6.13 トレースログ機能に関する設定
		6.13.1 取得できるトレースログの種類とマクロ
		6.13.2 トレースログ記録のサンプルコード
	◎6.14 コア識別
		◎6.14.1 コアID
		◎6.14.2 マスタコア
		◎6.14.3 ハードウェアに存在するコア数
	◎6.15 ロック
		◎6.15.1 ロック単位
		◎6.15.2 ロック方式
		◎6.15.3 ロック変数の型定義
		◎6.15.4 ロック操作関数
	◎6.16 コア間割込みドライバ
		◎6.16.1 コア間割込みドライバのファイル構成
		◎6.16.2 コア間割込みの初期化・終了処理・割込み処理
		◎6.16.3 コア間割込みの発行とクリア
		◎6.16.4 コア間割込みハンドラの登録
	◎6.17 コアコントロールブロック
	◎6.18 信頼フック，シャットダウンフックの強制終了
	◎6.19 コア起動
	6.20 ハードウェアカウンタ
		6.20.1 ハードウェアカウンタのファイル構成
		○6.20.2 ハードウェアカウンタの情報提供
７．ジェネレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2のテンプレートファイルのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数
		7.2.2 ターゲット非依存部で定義される変数
		◎7.2.3 マルチコア関連の定義（関数）
		◎7.2.4 コア毎のデータ構造の配置場所
		◎7.2.5 ターゲット非依存部で定義される関数
	7.3 パス3のテンプレートファイルのターゲット依存部
		7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数
	7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムモジュール等のターゲット依存部
	8.1 システムモジュールのターゲット依存部
	8.2 システムログ機能のターゲット依存定義
	8.3 シリアルインタフェースドライバのターゲット依存部
		8.3.1 変数，データ型，管理関数
		8.3.2 デバイスサービスルーチン
		8.3.3 コールバックルーチン
	8.4 カーネル起動メッセージの出力のターゲット依存定義
	8.5 サンプルプログラムとテストプログラムのターゲット依存定義
	8.6 実行時間分布集計モジュールのターゲット依存定義
	8.7 タイマドライバ
		8.7.1 タイマドライバのファイル構成
		8.7.2 ソフトウェアカウンタの定義
		8.7.3 時間型の定義
		8.7.4 タイマの初期化・終了処理・割込み処理
		8.7.5 現在の時刻の取得
９．その他
	○9.1 ドキュメント
１０．リファレンス
	○10.1 ターゲット依存部のファイル一覧

○がついている項目はATK2-SC1から変更があった箇所を，◎はATK2-SC1-MCで
新規に追加された箇所を示し，それぞれ差分のみを記述している．


０．前提

0.1 本マニュアルの位置づけ

TOPPERS/ATK2-SC1-MCは，シングルコア向けのTOPPERS/ATK2-SC1をベースとし
ているため，多くのポーティング項目はTOPPERS/ATK2-SC1と同一である．
そのため，TOPPERS/ATK2-SC1-MCをポーティングする前に，TOPPERS/ATK2-SC1
をポーティングすることを推奨する．本ドキュメントでは，TOPPERS/ATK2-SC1
からのポーティングに関して説明する．

0.2 動作アーキテクチャ

ATK2-SC1-MCを動作させるシステムは，次のアーキテクチャ（コア/バス/メモ
リ）を満たさなければならない．

(0-2-1) アドレス

各コアで，プログラムや固定データに対して，同一アドレスでアクセス可能で
あること．それぞれのプロセッサがアクセスする物理的なメモリが異なってい
てもよい．

(0-2-2) 共有メモリ

全コアから，同一のアドレスでアクセス可能なRAMがあること．（カーネルの
コントロールブロックはこの領域に配置する．）

(0-2-3) コア間割込み機能

任意のコアに割込み（コア間割込み）を発生可能であること．

(0-2-4) コア間排他制御機能

コア間での排他制御のための機構を持つこと．
  例 : test & set 命令， Mutex回路

(0-2-5) ロックの個数

コア間の排他制御機構を用いてロックを最低1個作成可能であること．1個のみ
の場合はジャイアントロック方式のみサポート可能．2個+コア毎に2個作成可
能であるとコアロック方式をサポート可能．

(0-2-6) コアID

各コアがユニークなIDを持ち，それをソフトウェアで読み込むことにより，自
コアを判別可能であること．


１．共通事項

1.1 ターゲット依存部の構成

ATK2-SC1から変更なし．

1.2 多重インクルードの防止

ATK2-SC1から変更なし．

1.3 アセンブリ言語とのヘッダファイルの共用 

ATK2-SC1から変更なし．

1.4 インクルード記述の方法

ATK2-SC1から変更なし．

1.5 クリティカルセクションの出入処理の実現に関する制約

ATK2-SC1から変更なし．

1.6 名前の衝突の防止

ATK2-SC1から変更なし．


２．システム構築環境のターゲット依存部

2.1 ターゲット略称とターゲット依存部のディレクトリ

ATK2-SC1から変更なし．

2.2 Makefileのターゲット依存部

ATK2-SC1から変更なし．

2.3 開発環境名とコマンド名の設定

ATK2-SC1から変更なし．

2.4 コンパイルオプションとオブジェクトファイルの設定

ATK2-SC1から変更なし．

2.5 オフセットファイルの生成方法

ATK2-SC1から変更なし．

2.5.1 ジェネレータを用いる方法

ATK2-SC1から変更なし．

2.6 リンク方法の設定

ATK2-SC1から変更なし．

2.7 依存関係の定義

ATK2-SC1から変更なし．

2.8 その他の設定

ATK2-SC1から変更なし．


３．AUTOSAR共通定義のターゲット依存部

3.1 整数型の最大値・最小値・ビット数

ATK2-SC1から変更なし．

3.2 整数型

ATK2-SC1から変更なし．

3.3 論理型，論理型の値

ATK2-SC1から変更なし．

3.4 その他の型

ATK2-SC1から変更なし．

3.5 コンパイラの拡張機能のためのマクロ定義

ATK2-SC1から変更なし．

3.6 標準的な定義の上書き

ATK2-SC1から変更なし．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

全割込み禁止状態の管理はコア毎に行う．

4.1 全割込み禁止状態の管理

(4-1-1) SIL_PRE_LOC

全割込み禁止フラグの状態を保存するための変数を定義するマクロ．コア毎に
独立した変数を用意する．

(4-1-2) SIL_LOC_INT()

呼び出したコアにおいて，現在の全割込み禁止フラグの状態をSIL_PRE_LOCで
定義した変数に保存し，全割込み禁止状態に遷移させるマクロ．

(4-1-3) SIL_UNL_INT()

呼び出したコアにおいて，SIL_LOC_INT()によって変数に保存した状態に戻す
マクロ．

4.2 プロセッサのエンディアン

ATK2-SC1から変更なし．

4.3 I/O空間アクセス関数

ATK2-SC1から変更なし．

4.4 スピンロック機能

SILのターゲット依存部では，スピンロックを用いたコア間の排他制御機能の
実現のため，スピンロックを取得する機能とスピンロックを返却する機能を提
供する．

SILの機能は，カーネルを使用しない場合にも使用できる必要がある．そのた
め，スピンロックの取得と解放は，カーネルを用いず，プロセッサのリソース
を直接操作することによって実現する．

スピンロックはカーネルが使用するものとは別に，システムインタフェースレ
イヤ用に確保する．使用するスピンロックは，カーネル起動時にターゲット依
存部で初期化すること．

(4-4-1) SIL_LOC_SPN

システムインタフェースレイヤ用のスピンロックを取得するマクロ．このマク
ロを実現する際には，「1.5 クリティカルセクションの出入処理の実現に関す
る制約」の節に記述されている制約に従わなければならない．SIL_LOC_SPNは，
SIL_LOC_INTの機能を包含する．すなわち，SIL_LOC_SPNに成功すると全割込み
ロック状態になる．また，SIL_LOC_INT と同様に，用いる関数またはブロック
の先頭の変数宣言部に SIL_PRE_LOC を記述しなければならない．

(4-4-2) SIL_UNL_SPN

システムインタフェースレイヤ用のスピンロックを返却するマクロ．このマク
ロを実現する際には，「1.5 クリティカルセクションの出入処理の実現に関す
る制約」の節に記述されている制約に従わなければならない．

(4-4-3) TOPPERS_sil_force_unl_spn

システムインタフェースレイヤ用のスピンロックを取得している場合に解放す
る関数．割込み禁止状態は変更しない．この関数は，カーネル内部からのみ呼
び出す．

4.5 コアIDの取得

(4-5-1) sil_get_coreid(ID *p_coreid)

呼び出したコアのコアIDを取得する．


５．カーネルAPIのターゲット依存部

5.1 メモリ領域確保のための型定義

ATK2-SC1から変更なし．

5.2 メモリ領域確保のためのマクロ

ATK2-SC1から変更なし．

5.3 オブジェクト型の上書き

(5-3-1) OMIT_DATA_TYPE (オプション)

OMIT_DATA_TYPEマクロをターゲット依存部で定義した場合は，一部のオブジェ
クトの型をターゲット依存部で定義することができる．

(5-3-16)  CoreIdType           (オプション，デフォルトはuint16)
(5-3-17)  SpinlockIdType       (オプション，デフォルトはuint32)
(5-3-18)  IocType              (オプション，デフォルトはuint32)
(5-3-19)  SenderIdType         (オプション，デフォルトはuint8)


６．カーネル実装のターゲット依存部

6.1 カーネル実装のターゲット依存部の共通事項

6.1.1 カーネル実装のターゲット依存部の構成要素

カーネル実装のターゲット依存部は，以下の要素で構成される．

(d) コア間割込みドライバ

コア間で割込みを発生させるためのコア間割込みドライバのヘッダファイル，
実装ファイルを，それぞれ，target_ici.h，target_ici.cに含める．プロセッ
サ・チップ・開発環境依存部を切り分けることも可能である．

6.1.2 ターゲット依存部の関数の命名規則

ATK2-SC1から変更なし．

6.2 トレースログ機能への対応

ATK2-SC1から変更なし．

6.3 システム状態の管理

ATK2-SC1から変更なし．

6.3.1 全割込み禁止状態の管理

ATK2-SC1から変更なし．

6.3.2 コンテキストの管理

ATK2-SC1から変更なし．

6.3.3 OS割込み禁止状態の管理

ATK2-SC1から変更なし．

6.4 割込みに関連するシステム状態の管理

6.4.1 割込み優先度マスクの管理

ATK2-SC1から変更なし．

6.4.2 割込みハンドラの先頭処理と末尾処理

ATK2-SC1から変更なし．

6.5 タスクディスパッチャ

6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック

ATK2-SC1から変更なし．

6.5.2 ディスパッチャ本体

ディスパッチャ本体で扱うp_runtsk/p_schedtsk/callevel_stat/p_currentosap
は，自コアのccb(my_ccb)が保持しているものとする．OS割込み禁止状態は
ディスパッチャ本体を実行しているコアを対象とする．

----------------------------------------
void
dispatcher(void)
{
#ifdef CFG_USE_STACKMONITORING
	スタックポインタ方式によるスタックモニタリング
	マジックナンバー方式によるスタックモニタリング
#endif /* CFG_USE_STACKMONITORING */

#ifdef CFG_USE_POSTTASKHOOK
	if (PostTaskHook != 0) {
		非タスクコンテキストに切り替える
		call_posttaskhook();
		コンテキストを戻す
	}
#endif /* CFG_USE_POSTTASKHOOK */

  dispatcher_0:
#ifdef LOG_DSP_ENTER
	log_dsp_enter(my_ccb.p_runtsk);
#endif /* LOG_DSP_ENTER */

	if (my_ccb.callevel_stat & TSYS_DISALLINT) {
		my_ccb.callevel_stat &= ~TSYS_DISALLINT;
		全割込み禁止を解除する
	}

  dispatcher_1:
	while ((my_ccb.p_runtsk = my_ccb.p_schedtsk) == NULL) {
		割込みを許可したらOS割込み禁止解除状態になるよう準備する
		非タスクコンテキストに切り換える
		OS割込み禁止を解除し，割込み発生を待つ … (*1)
		自コアをOS割込み禁止状態に戻す … (*2)
		タスクコンテキストに戻す
	}
	my_ccb.p_currentosap = my_ccb.p_runtsk->p_osapinib … (*3)
	自タスク（my_ccb.p_runtsk）のTCBからスタックポインタを復帰する
#ifdef LOG_DSP_LEAVE
	log_dsp_leave(my_ccb.p_runtsk);
#endif /* LOG_DSP_LEAVE */

#ifdef CFG_USE_PRETASKHOOK
	if (PreTaskHook != 0) {
		非タスクコンテキストに切り替える
		call_pretaskhook();
		タスクコンテキストに戻す
	}
#endif /* CFG_USE_PRETASKHOOK */

	自タスク（my_ccb.p_runtsk）のTCBから実行再開番地を復帰し，そこへ分岐する
}
----------------------------------------

(*3)のp_currentosapは，（p_runtskに相当） 現在 RUNNING のタスクが所属する
OSアプリケーションを示す変数である．

6.5.3 タスクコンテキストからのディスパッチ

ディスパッチ（dispatch）で扱うp_runtskやp_schedtskは，自コアのccb
(my_ccb)が保持しているものとする．

6.5.4 ディスパッチャの動作開始

ディスパッチャの動作開始（start_dispatch）で扱うOS割込み禁止状態・割込
み優先度マスクは，start_dispatchを実行しているコアのものを対象とする．

6.5.5 現在のコンテキストを捨ててディスパッチ

ATK2-SC1から変更なし．

6.5.6 タスクの起動処理

ATK2-SC1から変更なし．

6.6 割込みハンドラ

マルチコアのハードウェア割込みのタイプは大きく二つに分けることができ
る．1つ目は，単一の割込みコントローラを全てのコアで共有しており，割込
みを任意のコアで受け付けることが出来るタイプで，SMP割込み型と呼ぶ．も
う一方は，コア毎に割込みコントローラを持ち，割込みは特定のコアに固定さ
れているタイプで，AMP割込み型と呼ぶ．

割込み番号と割込みハンドラ番号を引数とする関数については，上位ビットフ
ィールドに（32bitの場合は上位16bit）に割込みを受け付けるコアのコアIDが
指定された値が渡されるため，必要に応じてマスクしてから扱うこと．

割込み管理のための管理ブロックは，ターゲット依存部のジェネレータテンプ
レートファイル（target.tf）内で生成する．SMP割込みの場合は，システムで
単一の管理ブロックを生成するのが一般的であり，AMP割込みの場合は，コア
毎に管理ブロックを生成するのが一般的である．

6.6.1 割込みハンドラの出入口処理

C2ISRの割込みの出入口処理の方法は，プロセッサによって大きく異なるが，
おおよその処理内容は次の通り．
p_runtsk/p_runisr/callevel_stat/p_currentosapは，自コアのccb(my_ccb)が保持
しているものとする．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	少なくともOS割込みを禁止した状態にする … (*f)
	スクラッチレジスタをスタックに保存する
	if (タスクコンテキストで割込み発生) {
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
	割込み優先度マスクを，受け付けた割込み要求の割込優先度に設定し，
				OS割込み禁止解除状態にする（受け付けた割込みよりも
				優先度の高い割込みを受け付けるようにする）… (*i)

#ifdef CFG_USE_STACKMONITORING
	if (タスクコンテキストで割込み発生) {
		スタックポインタチェック方式でタスクスタックのスタックモニタリ
		ングを行う
		マジックナンバーチェック方式でタスクスタックのスタックモニタリ
		ングを行う
	}
	else {
		スタック残量チェック方式でC2ISR用スタックのスタックモニタ
		リングを行う
		マジックナンバーチェック方式でC2ISR用スタックのスタックモニタ
		リングを行う
	}
#endif /* CFG_USE_STACKMONITORING */

	my_ccb.callevel_statを保存
	my_ccb.callevel_statに割込みビットを立てる
	my_ccb.p_currentosapを保存
	my_ccb.p_runisrを保存
	my_ccb.p_runisrを実行するC2ISRに設定する
	my_ccb.p_currentosapを実行するC2ISRが所属するOSアプリケーションに設定する

	C2ISRを呼び出す

#ifdef CFG_USE_STACKMONITORING
	マジックナンバーチェック方式でC2ISR用スタックのスタックモニタリン
	グを行う
#endif /* CFG_USE_STACKMONITORING */

	exit_isr2();			/* C2ISRの不正終了チェック */

	my_ccb.p_runisrを復帰
	my_ccb.callevel_statを復帰

  ret_int:
	if (タスクコンテキストで割込み発生) {
		（少なくとも）OS割込みを禁止した状態にする
		スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
		if (p_runtsk != p_schedtsk) {
			OS割込み禁止状態にする … (*e)
			割込み優先度マスクを，全解除状態（TIPM_ENAALL）に設定する
								 … (*h)
			スクラッチレジスタを除くすべてのレジスタをスタックに保存す
			る
			スタックポインタを自タスク（p_runtsk）のTCBに保存する
			ret_int_rを，実行再開番地として自タスクのTCBに保存する

			dispatcherに分岐する

		  ret_int_r:
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰
			する
		}
	}
	割込み処理からのリターン後に，割込み優先度マスクが
								割込み処理前の値に戻るように準備する
	割込み処理からのリターン後に，OS割込み禁止解除状態に戻るように準備
	する
	スクラッチレジスタをスタックから復帰する
	割込み処理からのリターン
}
----------------------------------------

6.6.2 割込み要求ラインの属性の設定

(6-6-2-1) void x_config_int(InterruptNumber intno,
							AttributeType intatr,
							PriorityType intpri,
                            CoreIdType coreid)

MCの場合は，関数の引数に，intnoが割り当てられたコアのIDであるcoreidが
渡される．
割込み要求ラインの初期化を，マスタコアで実施するか，intnoが割り当てら
れた各コアで実施するかはターゲット依存であるため，coreidを渡している．

6.6.3 割込み管理機能の初期化処理の変更

ATK2-SC1から変更なし．

6.6.4 デフォルトのC2ISR

ATK2-SC1から変更なし．

6.6.5 カーネル管理外の割込み

ATK2-SC1から変更なし．

6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更

ATK2-SC1から変更なし．

6.6.7 割込み番号のマルチコア拡張

割込み番号に関しては，複数のコアに接続された割込み要求ラインに対して
は，割込み番号の上位ビットを0とし，1つのコアのみに接続された割込み要求
ラインに対しては，割込み番号の上位ビット(32bitの場合は上位16bit)に接続
されたコアの(ID番号+1)を含める．例えば，コアID 1 のコアのみに接続され
た識別番号が 3 の割込み要求ラインの32bitCPUでの割込み番号は，
0x00020003 となる．

6.7 スタックモニタリング

ATK2-SC1から変更なし．

6.8 CPU例外ハンドラ

ATK2-SC1から変更なし．

ただし，スタック領域などコア毎に管理しているものを，自コア管理のものを
使用するという拡張を行う必要がある．

6.9 エラーフック，シャットダウンフック呼び出し

ATK2-SC1から変更なし．

6.10 カーネルの起動・終了とスタック領域など

(6-10-1) スタートアップモジュール

スタートアップモジュールでは，プロセッサのモード設定やスタックポインタ
の設定といった，各コアのプライベートな設定は各コアで行う．一方，共有メ
モリのbssセクションのクリアと，dataセクションの初期化といった，共有リ
ソースの初期化処理は可能な限りマスタコアで行う．

マスタコア以外は，StartCoreによるコア起動要求を待ち合わせる．StartCore
要求後StartOSを呼び出し，カーネルの起動を行う．
以下はAUTOSAR OSの起動に関する仕様をマスタ-スレーブ方式のエミュレート
で実現した場合の内容である．

(a) 自ハードウェアの初期化

システムのリセット後すぐに各コアで行う必要のある初期化処理を行う．

(b) hardware_init_hookの呼び出し

システムのリセット後すぐに行う必要のあるターゲットシステム依存の初期化
処理を行う．SMPタイプのハードウェアでは，マスタコアのみ実行するのが一
般的である．プライベートリソースが存在する場合はそれぞのコアで初期化す
る．

(c) bssセクションとdataセクションの初期化

C言語を動作させるための，メモリの初期化を行う．マスタコアのみ行うのが
一般的である．プライベートメモリは，それぞれのコアで初期化する．
マルチコアにおいて，下記リストの変数を0に初期化するだけで十分である．
各コアのCCB領域を，CCB定義先頭7変数(最低でも8バイト分)を初期化する必要
がある．

(d) StartCore待ち

スレーブコアでは，StartCoreで起動要求が実行されるまで，ループなどで待
ちとする．マスタコアであれば待ちは実施しない．

(d) software_init_hook()の呼び出し

開発環境（特にライブラリ）に依存して必要な初期化処理を行う．一般的には，
マスタコアのみで行う．

(e) kernel_target_hardware_initializeを呼び出す

ATK2-SC1から変更なし．

(f) mainへ分岐

mainを呼び出す．mainの中でStartOSが呼ばれる．
マスタコアであれば，StartOS前に起動が必要なスレーブコアに対し，
StartCoreを行なう．

(g) バリア同期

StartOS内で，アプリケーションモードの決定前，システム定義スタートアッ
プフック実行前，OSAP固有スタートアップフックの実行後のカーネル動作前に
それぞれ同期を行う．

(6-10-2) void target_initialize(void)

ATK2-SC1から変更なし．

(6-10-3) void target_exit(void)

ATK2-SC1から変更なし．

(6-10-4) OMIT_BARRIER_SYNC

カーネルの動作スタート/終了時用のバリア同期の関数を共通部で定義された
物ではなく，依存部で用意した関数を用いる場合に定義する．

(6-10-5) void barrier_sync(uint8 phase, boolean check_ext_ker);

カーネルの動作スタート/終了時用のバリア同期の関数．OMIT_BARRIER_SYNCを
定義して，ターゲット依存部でバリア同期の関数を定義する場合にこの仕様で
定義する．引数のphaseは同期のフェーズが指定される．check_ext_kerは同期
中にシャットダウン要求が発生したか確認の必要がある同期フェーズかどうか
の指定を行う．

(6-10-6) カーネルの終了

ShutdownAllCores()を呼び出されたコアから他のコアに対して終了処理を要求
してシステム全体をシャットダウンさせる．

(a)他のコアへの通知

標準では，共通部で用意されているディスパッチ要求用のコア間割込みを流用
した関数を用いる．ターゲット依存部で定義したい場合は，後述のマクロを定
義すればよい．

(b)OSAP固有シャットダウンフックの呼び出し

シャットダウンを行うコアに割り付けたOSAP固有のシャットダウンフックを順
次呼び出す．

(c)バリア同期

各コアでOSAP固有シャットダウンフック実行の終了を待ち合わせる．

(d)システム定義シャットダウンフックの呼び出し

各コアでシステム定義シャットダウンフックの呼び出しを行う．

(e)target_exit()の呼び出し

target_exit()を呼び出して，ターゲット依存部の終了処理を行い，その後無
限ループで終了となる．

(6-10-7) 終了処理関連の関数

ターゲット依存部では，カーネル終了処理要求関数（必要ならば）用意する．
バリア同期関数に関しては，起動処理と同じ関数を用いるため，終了処理用に
用意する必要はない．

(6-10-7-1) OMIT_KER_REQ_ON_ICI

他のコアに対するカーネル終了処理要求をディスパッチ要求用のコア間割込み
ハンドラで兼用させない場合に定義する．

(6-10-7-2) void shutdown_request(void)

他のコアに対するカーネル終了処理要求をディスパッチ要求用のコア間割込み
ハンドラで兼用させない場合に，ターゲット依存部で用意する．
カーネル終了処理関数（ShutdownAllCores()）で呼び出される．

6.11 カーネル内部のチューニング

6.11.1 ビットマップサーチ

ATK2-SC1から変更なし．

6.12 カーネル実装に関するその他の定義

6.12.1 エラーチェック方法の指定

ATK2-SC1から変更なし．

6.12.2 非タスクコンテキスト用のスタック領域

ATK2-SC1から変更なし．

6.12.3 空ラベルの定義

ATK2-SC1から変更なし．

6.12.4 各スタックのデフォルト値

ATK2-SC1から変更なし．

6.12.5 スタックマジックナンバー領域操作マクロの定義

ATK2-SC1から変更なし．

6.13 トレースログ機能に関する設定

6.13.1 取得できるトレースログの種類とマクロ

ATK2-SC1から変更なし．

6.13.2 トレースログ記録のサンプルコード

ATK2-SC1から変更なし．

6.14 コア識別

6.14.1 コアID

コアIDは，0から連続した番号を個々のコアに割り付けたものである．どのコ
アにどのIDを割り付けるかは，ターゲット依存で決める．

ターゲット依存部は，実行中のコアのコアIDを判別する機能を提供する．

(6-14-1-1) CoreIdType x_core_id(void)

処理単位が実行されているコアのIDを返す関数．ハードウェアの持つ
コア識別(HW-ID)のためのIDからコアIDを求めて返す．
HW-IDが0から連続した値でない場合には，この関数内で適切に変換する．

target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

6.14.2 マスタコア

システム中の特定の1個のコアを示す．マスタコアは，他コアの起動等を
行う．どのコアをマスタコアとするかは，ターゲット依存で決定する．ターゲ
ット依存部では，実行中のコアがマスタコアかを判別する機能を提供する．

(6-14-2-1) boolean x_sense_mcore(void)

処理単位が実行されているコアがマスタコアならTRUE，マスタコアでなければ
FALSEを返す関数．

(6-14-2-2) OS_CORE_ID_MASTER

マスタコアのIDをカーネル共通構成マクロとして定義する．

6.14.3 ハードウェアに存在するコア数

TNUM_HWCOREは，ハードウェアに存在するコア数を扱う．これはターゲット
依存部で定義必須である．

6.15 ロック

6.15.1 ロック単位

ターゲット依存部では，ロック単位の違いによる2種類のロック単位のうちの
一つを選択する．

(6-15-1-1) TTYPE_KLOCK

ロック単位を指定するマクロ．指定可能な単位は以下のロック単位のうちのい
ずれかである．

target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

(6-15-1-2) G_KLOCK ジャイアントロック

ジャイアントロックを有効にするマクロ．ジャイアントロックは，システムで
1つのロックを使用する．すべてのシステムサービスが排他的に実行される．

(6-15-1-3) C_KLOCK コアロック

コアロックを有効にするマクロ．コア毎にタスクロックとカウンタロックと，
全体でスピンロックロックとIOCロックを用いる方式．コア数 x 2 + 2個のロ
ックが必要．異なるコアに割り付けられている実行単位へのシステムサービス
は同時に実行可能．また，異なるオブジェクトロックコアに割り付けられてい
るオブジェクトへのシステムサービスは同時に実行可能．

6.15.2 ロック方式

ターゲット依存部では，スピンロックを実現するための排他制御におけるロッ
ク方式(排他制御ハードウェアの割当て方，ロックアルゴリズム)を選択する．

カーネルオブジェクトのスピンロックの実現方式としては，スピンロックオブ
ジェクトとハードウェアのスピンロックを1対1に対応させたネイティブ方式と，
オブジェクトロックにより，擬似的にスピンロックを実現するエミュレーショ
ン方式の2種類をサポートする．

(6-15-2-1) TTYPE_SPN

ロック方式(スピンロック)を指定するマクロ．指定可能な方式は以下のロック
方式である．

(6-15-2-2) NATIVE_SPN   ネイティブ方式の指定
(6-15-2-3) EMULATE_SPN  エミュレーション方式の指定

(6-15-2-4) TMAX_NATIVE_SPN  ロックの最大数

ネイティブ方式の場合に，サポートするロックの最大数を定義するマクロ．

6.15.3 ロック変数の型定義

ターゲット依存部は，ロック形式毎にロック変数の型を定義する．なお，使用
しないロック形式については定義する必要はない．

target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

(6-15-3-1) LockType 

ロック変数の型．target_ccb.hまたはそこからインクルードされるファイル
（プロセッサ・チップ・開発環境依存部で用意されるヘッダファイルなど）に
含める．

ジャイアントロック方式時は，ロック変数はグローバル変数として mc.c 内で
宣言される．

コアロック方式の場合は，タスクロック変数とカウンタロック変数はタスクロ
ック，カウンタロック共にCCB内で宣言される．スピンロックロックとIOCロッ
クについてはグローバル変数としてmc.c 内で宣言される．

6.15.4 ロック操作関数

ターゲット依存部は，ロック形式毎にロックを操作する機能を提供する．これ
らは，使用しないロック形式の機能は定義する必要はない．各ロック形式と定
義する関数の対応表を以下に示す．

                                     G_KLOCK  C_KLOCK
x_initialize_giant_lock()              ○
x_initialize_tsk_lock()                         ○
x_initialize_cnt_lock()                         ○
x_initialize_spn_lock()                         ○
x_initialize_ioc_lock()                         ○
x_acquire_lock()                       ○       ○
x_release_lock()                       ○       ○
wait_spn_lock()                        ○       ○

(6-15-4-1) void x_initialize_giant_lock(LockType *p_giant_lock)

ジャイアントロック方式の初期化関数．カーネル起動時にマスタコアから呼び
出される．

(6-15-4-2) void x_initialize_tsk_lock(LockType *p_tsk_lock)

コアロック方式でのタスクロックの初期化関数．カーネル起動時に自コアのタ
スクロックを対象に呼び出される．

(6-15-4-3) void x_initialize_cnt_lock(LockType *p_obj_lock)

コアロック方式でのカウンタロックの初期化関数．カーネル起動時に自コアの
カウンタロックを対象に呼び出される．

(6-15-4-4) void x_initialize_spn_lock(LockType *p_spn_lock)

コアロック方式，エミュレーション方式でのスピンロックロックの初期化関数．
カーネル起動時にマスタコアから呼び出される．

(6-15-4-5) void x_initialize_ioc_lock(LockType *p_ioc_lock)

コアロック方式でのIOCロックの初期化関数．カーネル起動時にマスタコアか
ら呼び出される．

(6-15-4-6) void x_acquire_lock(LockType *p_lock);

1段目のロック取得関数．OS割込み禁止状態で呼び出される．p_lockに対して
ロックをの取得を試み，ロックが取得ができればリターン．ロックが取得がで
きなければ，一旦割込みを許可した後禁止して，ロックの取得を試みる．

(6-15-4-7) void x_release_lock(LockType *p_lock)

ロック解放関数．OS割込み禁止状態で呼び出される．p_lockのロックを解放す
る．

(6-15-4-8) void wait_spn_lock(void)

GetSpinlock内部で，スピンロックロックを解放してから再取得するタイト
ループにおいて，他のコアがスピンロックを取得できる隙間を空けるための
待ち時間を用意する．
具体的には，
    release_spn_lock()
    x_nested_unlock_os_int
    goto while(1)
    x_nested_lock_os_int
    acquire_spn_lock()
で，スピンロックロックを解放してから，スピンロックロックを再取得する
直前までの間に，acquire_spn_lock() が成功するだけの時間を空ける．

(6-15-4-9) void x_initialize_spn_lock(SpinlockIdType i, LockType *p_spn_lock)

コアロック方式，ネイティブ方式でのスピンロックの初期化関数．
カーネル起動時にマスタコアから呼び出される．

6.16 コア間割込みドライバ

6.16.1 コア間割込みドライバのファイル構成

コア間割込みドライバを組み込むための処理を，ターゲット依存部のコンフィ
ギュレーションファイル(target.tf)にて出力する．このファイルにて，コア
間割込みドライバを初期化するための初期化ルーチンの追加，コア間割込みを
停止させるための終了処理ルーチンの追加（必要ならば），コア間割込みのた
めの割込みハンドラの定義（または，割込みサービスルーチンの追加），コア
間割込みのための割込み要求ラインの属性の設定などを含むことになる．

コア間割込みドライバを呼び出すために必要な定義を含むヘッダファイルを，
target_ici.hに用意する．また，必要であれば，コア間割込みドライバの実装
ファイルをtarget_ici.cに用意する．

6.16.2 コア間割込みの初期化・終了処理・割込み処理

(6-16-2-1) void target_ici_initialize(uintptr exinf)

コア間割込みを初期化し，コア間割込み発行可能とする関数．この関数は初期
化ルーチンにて呼ばれることを想定している．必要としない場合は，用意する
必要はない．

(6-16-2-2) void target_ici_terminate(uintptr exinf)

コア間割込みを停止させ，コア間割込みを発生しないようにする関数．この関
数は，終了処理ルーチンにて呼ばれることを想定している．必要としない場合
は，用意する必要はない．

6.16.3 コア間割込みの発行とクリア

(6-16-3-1) void target_ici_raise(CoreIdType coreid)

コア間割込みを発行する関数．引数には割込み発生先のコアIDが指定される．

(6-16-3-2) void target_ici_clear(void)

コア間割込みをクリアする関数．コア間割込みを受け付けたコアのコア間割込
みハンドラで呼び出される．

6.16.4 コア間割込みハンドラの登録

共通部では，コア間割込みで呼び出される割込みハンドラ 
ici_handler_main() が用意されている．

この関数は，ターゲット依存部のコンフィギュレーションファイル
(target.tf)にて，割込みハンドラまたは割込みサービスルーチンとしてカー
ネルに登録された延長で呼び出されることを想定している．

6.16.5 コア間割込み優先度

コア間割込み毎の割込み優先度を指定する．

6.16.6 コア間割込みの割込み番号

コア間割込みの割込み番号を次のマクロに定義する．

CORE_INT_0_INT，CORE_INT_1_INT，CORE_INT_3_INT，CORE_INT_4_INT

6.17 コアコントロールブロック

ターゲット依存でコア毎に必要な変数は，ターゲット依存のコアコントロール
ブロック（TCCB）としてまとめ，CCB内でコア毎に生成される．TCCBの定義は
，target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チ
ップ・開発環境依存部で用意されるヘッダファイルなど）に含める．

target_ccb.hまたはそこからインクルードされるファイルには，以下の内容を
含める必要がある．

  ・前方参照用のCCBのtypedef宣言
    typedef struct core_control_block CCB
  ・TCCBの定義
  ・(6-14-1-1) CoreIdType x_core_id(void) の定義
  ・6.15.1 ロック方式 の指定
  ・6.15.2 ロック変数の型定義

6.18 信頼フック，シャットダウンフックの強制終了

(6-18-1) void call_trusted_hook(void *hook, StatusType arg)

call_trusted_hookはシャットダウンフック実行時にターゲット非依存部から呼
び出される．信頼フックの強制終了処理と，実行再開可能にするためレジスタ
の退避を行う．

(6-9-2) void exit_trusted_shutdown_hook(void)

exit_trusted_shutdown_hookはcall_trusted_hookにより実行されるフック
ルーチンから呼び出されることを想定している．信頼シャットダウンフックの
強制終了処理を行う．スタックに退避されているデータはcall_trusted_hook
実行時に退避されたものである．

6.19 コア起動

(6-19-1) LOCAL_INLINE boolean x_start_core(CoreIdType coreid)

指定されたコアの起動処理を行う．

----------------------------------------
LOCAL_INLINE boolean x_start_core(CoreIdType coreid)
{
	if (指定されたコアID＜サポートしているコア数) {
		(SYSVER_REG5 + 4 * coreid )に，MAGIC_STARTを書き込む
		TRUEを返す
	} else {
		FALSEを返す
	}
	返り値をリターン
}
----------------------------------------

(6-19-2) LOCAL_INLINE boolean is_halt(CoreIdType coreid)

指定されたコアが起動されたかの確認を行う．

----------------------------------------
LOCAL_INLINE boolean is_halt(CoreIdType coreid)
{
	if (SYSVER_REG5 + 4 * coreid )にMAGIC_STARTが書き込まれていない {
		TRUEを返す
	} else {
		FALSEを返す
	}
}
----------------------------------------

6.14 ハードウェアカウンタ

ATK2-SC1から変更なし．

6.14.1 ハードウェアカウンタのファイル構成

ATK2-SC1から変更なし．

6.14.2 ハードウェアカウンタの情報提供

マルチコアにおいては，互換性向上のため，コア毎に，
"MAIN_HW_COUNTER_COREx"(x:コアID)というハードウェアカウンタを用意するこ
とを推奨する．


７．ジェネレータ設定ファイルのターゲット依存部

7.1 設定ファイルとターゲット依存部の位置付け

ATK2-SC1から変更なし．

7.2 パス2のテンプレートファイルのターゲット依存部

7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数

ATK2-SC1から変更なし．

7.2.2 ターゲット非依存部で定義される変数

(7-2-2-7)OSAP.CORE[osapid]	osapidのOSAPを割付けたコアを示す連想配列
(7-2-2-8)TMAX_COREID		コアIDの最大値

7.2.3 マルチコア関連の定義（関数）

以下に示すオブジェクト管理ブロック等の配置を制御するため，ターゲット依
存部のパス2のテンプレートファイルにおいて， カーネルの構成・初期化ファ
イル（Os_Lcfg.c に)おいて変数を宣言する関数を用意する．なお，これらの
関数を宣言しない場合は，特に配置指定を行わない変数の宣言が生成される．
引数は対象のオブジェクトのID番号である．これらの変数の多くは，ローカル
メモリないし，グローバルメモリに配置可能である．タスクスタックはプライ
ベートメモリに配置可能である．

  1.カーネルオブジェクトのコントロールブロックの配置場所
  2.カーネルオブジェクトのコントロールブロック以外のメモリ領域（タスク
    スタック等バッファ領域の配置場所

(7-2-3-1)  GENERATE_TCB(tskid)   タスク管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	TCB kernel_tcb_$tskid$;$NL$

(7-2-3-2)  GENERATE_CNTCB(cntid) カウンタ管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	CNTCB kernel_cntcb_$cntid$;$NL$

(7-2-3-3)  GENERATE_ALMCB(almid) アラーム管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	ALMCB kernel_almcb_$almid$;$NL$

(7-2-3-4)  GENERATE_SCHTBLCB(schtblid) スケジュールテーブル管理ブロッ
									   クの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	SCHTBLCB kernel_schtblcb_$schtblid$;$NL$

(7-2-3-5)  GENERATE_RESCB(resid) リソース管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	RESCB kernel_rescb_$resid$;$NL$

(7-2-3-6)  GENERATE_ISRCB(isrid) C2ISR管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	ISRCB kernel_isrcb_$isrid$;$NL$

(7-2-3-7)  GENERATE_TSKSTK(tskid) タスクスタックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType kernel_stack_$tskid$[COUNT_STK_T($TSK.STKSZ[tskid]$)];$NL$

(7-2-3-8)  GENERATE_SHARED_TSKSTK(coreid, shared_stkid, shared_stack_size) 
基本タスクの共有スタックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType kernel_shared_stack_$shared_stkid$[COUNT_STK_T($shared_stack_size[shared_stkid]$)];$NL$

スタック共有される場合，共有されて使用されるタスクスタック毎に，
kernel.tf内でIDを割り振り，shared_stkidとなる．また共有するタスク毎の
スタックの最大値がshared_stack_sizeとしてスタックサイズになる．

7.2.4 コア毎のデータ構造の配置場所

ターゲット依存部のパス2のテンプレートファイルでは，ターゲット非依存部
をインクルードする前に，カーネルの構成・初期化ファイル（Os_Lcfg.c に)
おいて宣言されるカーネル内でプロセッサ毎に必要となる以下のデータ構造に
対して，配置先の指定のための関数を定義する．なお，これらの関数を宣言し
ない場合は，特に配置指定を行わない変数の宣言が生成される．

 1.CCB
   ・他コアからアクセス可能な領域に配置すること．
 2.OS用のスタック
    ・自コアからのみアクセスできる領域に配置可能．

(7-2-4-1) GENERATE_CCB(id) コアコントロールブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	CCB kernel_core$id$_ccb;$NL$

(7-2-4-2) GENERATE_OSSTACK_DEF(coreid) 
OS用スタックの宣言関数(スタックサイズ指定あり)

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType kernel_core$coreid$_ostack[COUNT_STK_T($OSTK.STKSZ[OSTK.COREID[coreid]]$)];$NL$

OS用スタックは，コンテナOsOsStackで指定され，C2ISR,フック実行時に使用
されるスタック．

(7-2-4-3) GENERATE_OSSTACK(coreid, total_stksz)
OS用スタックの宣言関数(スタックサイズ指定なし)

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType kernel_core$coreid$_ostack[$FORMAT("COUNT_STK_T(0x%x)", +total_stksz[coreid])$];$NL$

total_stkszは，スタックサイズ指定がなかった場合に，必要な量をkernel.tf
内で計算した結果である．

7.2.5 ターゲット非依存部で定義される関数

(7-2-5-1) DEFINE_IOC_MACRO(関数名)	IOCの関数宣言におけるマクロ

DEFINE_IOC_MACROマクロは，IOCのプロパティでMACROが
指定された場合の関数宣言を生成する際に用いる．
DEFINE_IOC_MACROマクロをターゲット依存部で定義した場合は，
関数の型をターゲット依存部で定義することができ，
型としてはStd_ReturnTypeが返り，マクロの引数が関数名となる．


7.3 パス3のテンプレートファイルのターゲット依存部

7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数

ATK2-SC1から変更なし．

7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル

ATK2-SC1-MCでは，一般的には，target_cfg1_out.h（または，そこからイン
クルードされるファイル）に以下のような定義を含める必要がある．

----------------------------------------
int
main(void)
{
	return 0;
}

#define TotalNumberOfCores 1
StackType * const	kernel_ostkpt_table[TotalNumberOfCores];

const uint8			MAGIC_1 = UINT_C(0x12);
const uint16		MAGIC_2 = UINT_C(0x1234);
const uint32		MAGIC_4 = UINT_C(0x12345678);

kernel_target_hardware_initialize(void)
{
}
----------------------------------------


８．システムモジュール等のターゲット依存部

8.0 システムモジュールのターゲット依存部

ATK2-SC1から変更なし．

8.1 システムログ機能のターゲット依存定義

ATK2-SC1から変更なし．

8.2 シリアルインタフェースドライバのターゲット依存部

8.2.1 変数，データ型，管理関数

ATK2-SC1から変更なし．

8.2.2 デバイスサービスルーチン

ATK2-SC1から変更なし．

8.3 カーネル起動メッセージの出力のターゲット依存定義

ATK2-SC1から変更なし．

8.4 サンプルプログラムとテストプログラムのターゲット依存定義

ATK2-SC1から変更なし．

8.5 実行時間分布集計モジュールのターゲット依存定義

ATK2-SC1から変更なし．

8.6 タイマドライバ

8.6.1 タイマドライバのファイル構成

ATK2-SC1から変更なし．

8.6.2 ソフトウェアカウンタの定義

ATK2-SC1から変更なし．

8.6.3 時間型の定義

ATK2-SC1から変更なし．

8.6.4 タイマの初期化・終了処理・割込み処理

ATK2-SC1から変更なし．

8.6.5 現在の時刻の取得

ATK2-SC1から変更なし．


９．その他

9.1 ドキュメント

(1) 対応しているターゲットシステムの種類・構成，バージョン番号
	・サポートしているコア数

(3-8) OS内部のロック単位
  ・ジャイアントロック と コアロックのサポート有無や選択方法．

(3-9) スピンロック方式
  ・ネイティブ方式 と エミュレーション方式 のサポート有無や選択方法．
    ネイティブ方式 の場合の最大数．

(3-10) メモリアーキテクチャ
  ・データの配置場所の制御方法．


１０．リファレンス

10.1 ターゲット依存部のファイル一覧

標準的なターゲット依存部のファイル構成は次の通りである．

target_ici.h	コア間割込みハンドラドライバのヘッダファイル（6.16節）．
				カーネルのみからインクルードされる．
target_ici.c	コア間割込みハンドラドライバの実装ファイル
				（6.16節，オプション）．
target_ccb.h	依存部のコアコントロールブロックのヘッダファイル
				（6.17節）．
以上
